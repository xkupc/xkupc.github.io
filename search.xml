<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[神奇的springboot注解]]></title>
      <url>/2017/09/21/%E7%A5%9E%E5%A5%87%E7%9A%84springboot%E6%B3%A8%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>小编接触springboot的时间很短，平时也就拿着已经成熟的框架，写着无关痛痒的业务代码，在看druid的源码的时候，涉猎了很多注解，发现通过简单的一个注解，使大量的配置属性初始化到bean里，对我这种还停留在@value级别的小白来说简直大开眼界了。今天想着介绍一下springboot里我刚刚学到的几个厉害的注解。</p>
<h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><p>在介绍厉害的之前我们先来入个门，这个注解在spring里就已经存在了，是spring用来替代通过xml配置bean的繁琐方式的。在spring里使用这个注解，我们需要在xml里指定扫描的路径，而在springboot里我们就完全不用指定，只要保证springboot启动入口的路径包含了注解所在的包就可以了。在springboot里这个注解一般用来在系统启动时初始化系统数据源，数据库中间件等一些系统配置项。<br>下面我们通过一个例子来看看：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">@Configuration</div><div class="line">public class UserConfig &#123;</div><div class="line">    @Value(&quot;$&#123;user.name&#125;&quot;)</div><div class="line">    private String userName;</div><div class="line">    @Value(&quot;$&#123;user.age&#125;&quot;)</div><div class="line">    private int userAge;</div><div class="line">    @Value(&quot;$&#123;user.cityId&#125;&quot;)</div><div class="line">    private String cityId;</div><div class="line">    @Value(&quot;$&#123;user.proviceId&#125;&quot;)</div><div class="line">    private String proviceId;</div><div class="line"></div><div class="line">    @Bean</div><div class="line">    public BaseModel baseModel()&#123;</div><div class="line">        BaseModel baseModel = new BaseModel();</div><div class="line">        baseModel.setUserName(userName);</div><div class="line">        baseModel.setUserAge(userAge);</div><div class="line">        baseModel.setCityId(cityId);</div><div class="line">        baseModel.setProviceId(proviceId);</div><div class="line">        return baseModel;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">    //测试</div><div class="line">    @Autowired</div><div class="line">    BaseModel baseModel;</div><div class="line"></div><div class="line">    @Test</div><div class="line">    public void getBaseModel()&#123;</div><div class="line">        System.out.println(baseModel.toString);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="ConfigurationProperties、EnableConfigurationProperties"><a href="#ConfigurationProperties、EnableConfigurationProperties" class="headerlink" title="ConfigurationProperties、EnableConfigurationProperties"></a>ConfigurationProperties、EnableConfigurationProperties</h2><p>有了上面Configuration的基础，我们来看看ConfigurationProperties是做了些啥呢。<br>修改一下baseModel实体类和UserConfig配置类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">//使用ConfigurationProperties注解，设置配置文件里关联属性的key的前缀</div><div class="line">@ConfigurationProperties(prefix = &quot;user&quot;)</div><div class="line">public class BaseModel&#123;</div><div class="line">    private String userName;</div><div class="line">    private int userAge;</div><div class="line">    private String cityId;</div><div class="line">    private String proviceId;</div><div class="line"></div><div class="line">    public String getUserName() &#123;</div><div class="line">        return userName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setUserName(String userName) &#123;</div><div class="line">        this.userName = userName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getUserAge() &#123;</div><div class="line">        return userAge;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setUserAge(int userAge) &#123;</div><div class="line">        this.userAge = userAge;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getCityId() &#123;</div><div class="line">        return cityId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setCityId(String cityId) &#123;</div><div class="line">        this.cityId = cityId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getProviceId() &#123;</div><div class="line">        return proviceId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setProviceId(String proviceId) &#123;</div><div class="line">        this.proviceId = proviceId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return &quot;BaseModel&#123;&quot; +</div><div class="line">                &quot;userName=&apos;&quot; + userName + &apos;\&apos;&apos; +</div><div class="line">                &quot;, userAge=&quot; + userAge +</div><div class="line">                &quot;, cityId=&apos;&quot; + cityId + &apos;\&apos;&apos; +</div><div class="line">                &quot;, proviceId=&apos;&quot; + proviceId + &apos;\&apos;&apos; +</div><div class="line">                &apos;&#125;&apos;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//UserConfig配置类</div><div class="line">//这里还是使用Configuration初始化配置</div><div class="line">@Configuration</div><div class="line">//对BaseModel启用ConfigurationProperties，如果没有这个，默认不开启，那么在测试类里用Autowired就会报错</div><div class="line">@EnableConfigurationProperties(BaseModel.class)</div><div class="line">public class UserConfig &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当我把baseModel里的get、set方法删除时，就初始化不了，很明显，这里依旧还是反射，看官们可能觉得你也可以这么做，容我贴一下我的配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">user.user-name = test</div><div class="line">user.user-age = 12</div><div class="line">user.cityId = 330600</div><div class="line">user.proviceId =331000</div></pre></td></tr></table></figure></p>
<p>就问你惊不惊喜，意不意外。属性的key与baseModel里的属性名没有直接映射。如果我在baseModel里增加另一个类的依赖呢。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//新增实体类</div><div class="line">private UserCompany workCompany;</div><div class="line"></div><div class="line">//配置文件新增属性</div><div class="line">user.work-company.company-name = 凯歌集团</div><div class="line">user.work-company.companyPhone = 123456</div><div class="line"></div><div class="line">//测试用例修改</div><div class="line"> @Autowired</div><div class="line">  BaseModel baseModel;</div><div class="line"></div><div class="line">  @Test</div><div class="line">  public void getBaseModel()&#123;</div><div class="line">      System.out.println(baseModel.toString());</div><div class="line">      System.out.println(baseModel.getWorkCompany().toString());</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>依旧初始化成功。是时候看一波源码了。<br>打开EnableConfigurationProperties，我可以看到他引入一个EnableConfigurationPropertiesImportSelector,接下来我们看看这个Selector都做了些啥<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public String[] selectImports(AnnotationMetadata metadata) &#123;</div><div class="line">		MultiValueMap&lt;String, Object&gt; attributes = metadata.getAllAnnotationAttributes(</div><div class="line">				EnableConfigurationProperties.class.getName(), false);</div><div class="line">        // 获取注解EnableConfigurationProperties里配置的class</div><div class="line">		Object[] type = attributes == null ? null</div><div class="line">				: (Object[]) attributes.getFirst(&quot;value&quot;);</div><div class="line">		if (type == null || type.length == 0) &#123;</div><div class="line">			return new String[] &#123;</div><div class="line">					ConfigurationPropertiesBindingPostProcessorRegistrar.class</div><div class="line">							.getName() &#125;;</div><div class="line">		&#125;</div><div class="line">        //按demo里的例子，我们配置了@EnableConfigurationProperties(BaseModel.class)</div><div class="line">        //则将ConfigurationPropertiesBeanRegistrar和ConfigurationPropertiesBindingPostProcessorRegistrar</div><div class="line">        //完成BaseModel与配置属性的映射</div><div class="line">		return new String[] &#123; ConfigurationPropertiesBeanRegistrar.class.getName(),</div><div class="line">				ConfigurationPropertiesBindingPostProcessorRegistrar.class.getName() &#125;;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>我们看ConfigurationPropertiesBeanRegistrar里的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public void registerBeanDefinitions(AnnotationMetadata metadata,</div><div class="line">				BeanDefinitionRegistry registry) &#123;</div><div class="line">			MultiValueMap&lt;String, Object&gt; attributes = metadata</div><div class="line">					.getAllAnnotationAttributes(</div><div class="line">							EnableConfigurationProperties.class.getName(), false);</div><div class="line">			List&lt;Class&lt;?&gt;&gt; types = collectClasses(attributes.get(&quot;value&quot;));</div><div class="line">			for (Class&lt;?&gt; type : types) &#123;</div><div class="line">				String prefix = extractPrefix(type);</div><div class="line">				String name = (StringUtils.hasText(prefix) ? prefix + &quot;-&quot; + type.getName()</div><div class="line">						: type.getName());</div><div class="line">				if (!containsBeanDefinition((ConfigurableListableBeanFactory) registry,</div><div class="line">						name)) &#123;</div><div class="line">                    //实际上只做了一件事就是如果配置类（demo里的BaseModel）未被注入容器，则完成配置类的注入</div><div class="line">					registerBeanDefinition(registry, type, name);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
<p>ConfigurationPropertiesBindingPostProcessorRegistrar里的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,</div><div class="line">			BeanDefinitionRegistry registry) &#123;</div><div class="line">		if (!registry.containsBeanDefinition(BINDER_BEAN_NAME)) &#123;</div><div class="line">			BeanDefinitionBuilder meta = BeanDefinitionBuilder</div><div class="line">					.genericBeanDefinition(ConfigurationBeanFactoryMetaData.class);</div><div class="line">            //这里注入了ConfigurationPropertiesBindingPostProcessor完成属性与配置的绑定</div><div class="line">			BeanDefinitionBuilder bean = BeanDefinitionBuilder.genericBeanDefinition(</div><div class="line">					ConfigurationPropertiesBindingPostProcessor.class);</div><div class="line">			bean.addPropertyReference(&quot;beanMetaDataStore&quot;, METADATA_BEAN_NAME);</div><div class="line">			registry.registerBeanDefinition(BINDER_BEAN_NAME, bean.getBeanDefinition());</div><div class="line">			registry.registerBeanDefinition(METADATA_BEAN_NAME, meta.getBeanDefinition());</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> springboot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> spring-boot </tag>
            
            <tag> spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring-boot里druid连接池配置（三）]]></title>
      <url>/2017/09/21/spring-boot%E9%87%8Cdruid%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>上一篇我们知道druid实现监控的大致原理，今天我们学习一下，druid数据库连接池的实现。</p>
<h3 id="数据库连接池配置"><a href="#数据库连接池配置" class="headerlink" title="数据库连接池配置"></a>数据库连接池配置</h3><p>首先我们来看一下数据库数据源的初始化配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 主数据源</div><div class="line"> */</div><div class="line"></div><div class="line">@Bean(name = &quot;primaryDataSource&quot;)</div><div class="line">@Primary</div><div class="line">@ConfigurationProperties(prefix = &quot;spring.datasource.druid&quot;)</div><div class="line">public DataSource primaryDataSource() &#123;</div><div class="line">    return DruidDataSourceBuilder.create().build();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>获取spring.datasource.druid前缀的相关配置属性，初始化数据源。我们来看看druid为适配springboot开发的druid-spring-boot-starter都做了哪些事。<br><img src="/images/druid/druid-spring-boot-starter.png" alt="druid-spring-boot-starter代码结构"><br>从图中我们看到，这个包很简单，主要做了两个事，一个是通过springboot的数据源初始化机制初始化自己的数据源，通过DruidDataSourceWrapper兼容springboot的数据源配置，第二个是通过springboot的注解机制，通过配置初始化自定义的系列Filter。<br>是的，我们也可以通过配置文件配置我们上篇文章提到的statViewServlet和webStatFilter。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//初始化statViewServlet</div><div class="line">spring.datasource.druid.stat-view-servlet.enabled</div><div class="line">//初始化webStatFilter</div><div class="line">spring.datasource.druid.web-stat-filter.enabled</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>看这里，这个类完成了所有配置的初始化。<br><img src="images/druid/druid_starter.png" alt="druid初始化配置"><br>DruidStatProperties这个类加载了statViewServlet和webStatFilter的配置属性，然后分别通过DruidStatViewServletConfiguration和DruidWebStatFilterConfiguration以spring注册bean的方式完成注册，与我们直接通过代码的方式注册一样。<br>DataSourceProperties这个则加载了数据源的配置属性，然后通过DataSourceAutoConfiguration完成数据源初始化。<br>DruidDataSourceWrapper则完成了数据库连接池相关的配置，我们看到它继承了DruidDataSource。</p>
<h3 id="数据库连接池初始化"><a href="#数据库连接池初始化" class="headerlink" title="数据库连接池初始化"></a>数据库连接池初始化</h3><p>druid通过springboot加载完配置后，连接池是如何初始化的呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public DruidDataSource(boolean fairLock)&#123;</div><div class="line">     super(fairLock);</div><div class="line"></div><div class="line">     configFromPropety(System.getProperties());</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>看这里，有一个公平锁的概念，小编马上先谷歌了一下公平锁的概念，公平锁是为了解决cpu调度线程的时候随机选择线程，无法保证线程先到先得，从而导致某些优先级低的线程永远也无法获得cpu资源的问题。公平锁能够保证线程按照时间的先后顺序执行。既然要按顺序执行，那么就要维护一个有序的队列，这个开销就有点大了，果然公平是不容易实现的。druid默认是非公平锁。</p>
]]></content>
      
        <categories>
            
            <category> java中间件 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> druid </tag>
            
            <tag> spring-boot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring-boot里druid连接池配置（二）]]></title>
      <url>/2017/09/19/spring-boot%E9%87%8Cdruid%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%85%8D%E7%BD%AE%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>上篇我们简单介绍了druid的简单配置，利用druid实现了数据库的监控和配置密码的加密，今天我们从源码的角度分析druid的监控实现。</p>
<h3 id="数据库监控配置"><a href="#数据库监控配置" class="headerlink" title="数据库监控配置"></a>数据库监控配置</h3><p>在上篇的代码里我们通过springboot自带的Servlet注册Bean进行Servlet注册了StatViewServlet，通过自带的Filter注册bean注册了WebStatFilter，今天我们俩介绍一下这个两个bean的作用。</p>
<h2 id="StatViewServlet"><a href="#StatViewServlet" class="headerlink" title="StatViewServlet"></a>StatViewServlet</h2><p>看看它的配置，我们就知道，它是一个实现druid监控视图的servlet,通过这个servlet我们配置了监控视图web页的登录账号和密码，通过设置黑白名单ip配置web页的访问权限,接下来我们来看看这个配置在哪生效的。<br>跟踪StatViewServlet的父类ResourceServlet:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">private void initAuthEnv() &#123;</div><div class="line">       String paramUserName = getInitParameter(PARAM_NAME_USERNAME);</div><div class="line">       if (!StringUtils.isEmpty(paramUserName)) &#123;</div><div class="line">           this.username = paramUserName;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       String paramPassword = getInitParameter(PARAM_NAME_PASSWORD);</div><div class="line">       if (!StringUtils.isEmpty(paramPassword)) &#123;</div><div class="line">           this.password = paramPassword;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       String paramRemoteAddressHeader = getInitParameter(PARAM_REMOTE_ADDR);</div><div class="line">       if (!StringUtils.isEmpty(paramRemoteAddressHeader)) &#123;</div><div class="line">           this.remoteAddressHeader = paramRemoteAddressHeader;</div><div class="line">       &#125;</div><div class="line">       ....</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>可以看到通过initAuthEnv完成我们配置参数的初始化工作。接着我们来看看配置怎么生效的，既然是servlet，那必然会有service方法。很快我们在ResourceServlet里找到了service方法，我们来看看druid的登陆：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">if (&quot;/submitLogin&quot;.equals(path)) &#123;</div><div class="line">           String usernameParam = request.getParameter(PARAM_NAME_USERNAME);</div><div class="line">           String passwordParam = request.getParameter(PARAM_NAME_PASSWORD);</div><div class="line">           if (username.equals(usernameParam) &amp;&amp; password.equals(passwordParam)) &#123;</div><div class="line">               request.getSession().setAttribute(SESSION_USER_KEY, username);</div><div class="line">               response.getWriter().print(&quot;success&quot;);</div><div class="line">           &#125; else &#123;</div><div class="line">               response.getWriter().print(&quot;error&quot;);</div><div class="line">           &#125;</div><div class="line">           return;</div><div class="line">       &#125;</div></pre></td></tr></table></figure></p>
<p>这里druid简单的实现了一个登陆操作，将用户名作为一个session存储。当然作为一个内部使用的web页，我们不该有太多的苛求。接下来我们看看这个service还做了什么，我们看到service承担了整个监控视图的所有请求的处理和分发，对于数据库监控数据的请求，比如sql监控数据请求<a href="http://localhost:31009/druid/sql.json?orderBy=SQL&amp;orderType=desc&amp;page=1&amp;perPageCount=1000000&amp;" target="_blank" rel="external">http://localhost:31009/druid/sql.json?orderBy=SQL&amp;orderType=desc&amp;page=1&amp;perPageCount=1000000&amp;</a> 我们看druid是如何处理的呢，我们注意到这行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">if (path.contains(&quot;.json&quot;)) &#123;</div><div class="line">           String fullUrl = path;</div><div class="line">           if (request.getQueryString() != null &amp;&amp; request.getQueryString().length() &gt; 0) &#123;</div><div class="line">               fullUrl += &quot;?&quot; + request.getQueryString();</div><div class="line">           &#125;</div><div class="line">           response.getWriter().print(process(fullUrl));</div><div class="line">           return;</div><div class="line">       &#125;</div></pre></td></tr></table></figure></p>
<p>当所有包含.json请求的都会通过process方法来处理，小编突然觉得druid对url的处理实在是好简单，突然明白为嘛它作为一个数据库连接池，还要搞一个EncodingConvertFilter的过滤器了，大公司套路深，我要回农村。。。。<br>直接看process方法，我们在StatViewServlet找到了process方法，这个厉害了，druid还可以通过配置jmx连接地址，来监控远程druid服务。也就说我们可以将实现druid连接池的应用和监控视图的web应用分离，毕竟让一个内管后台直接访问生产机器还是有风险的。<br>继续跟踪我们发现所有的请求都是通过DruidStatService.service(url)进行处理的.我们来看看druid是否处理我们上面那个请求的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (url.startsWith(&quot;/sql.json&quot;)) &#123;</div><div class="line">          return returnJSONResult(RESULT_CODE_SUCCESS, getSqlStatDataList(parameters));</div><div class="line">      &#125;</div></pre></td></tr></table></figure></p>
<p>跟踪getSqlStatDataList方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">private List&lt;Map&lt;String, Object&gt;&gt; getSqlStatDataList(Map&lt;String, String&gt; parameters) &#123;</div><div class="line">       Integer dataSourceId = null;</div><div class="line"></div><div class="line">       String dataSourceIdParam = parameters.get(&quot;dataSourceId&quot;);</div><div class="line">       if (dataSourceIdParam != null &amp;&amp; dataSourceIdParam.length() &gt; 0) &#123;</div><div class="line">           dataSourceId = Integer.parseInt(dataSourceIdParam);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       List&lt;Map&lt;String, Object&gt;&gt; array = statManagerFacade.getSqlStatDataList(dataSourceId);</div><div class="line">       List&lt;Map&lt;String, Object&gt;&gt; sortedArray = comparatorOrderBy(array, parameters);</div><div class="line">       return sortedArray;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>这里有一个dataSourceId请求里是没有的，因为我们使用的是单数据源。<br>我们看到拿到请求结果后，druid对结果进行了排序和分页，我们学习下是如何排序和分页的。这里给我们一点在内存分页的启示了吧，不过话说页面把记录总数写死的做法这样真的好么，还好有重置选项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 排序方法</div><div class="line">if (orderBy.trim().length() != 0) &#123;</div><div class="line">    Collections.sort(array, new MapComparator&lt;String, Object&gt;(orderBy, ORDER_TYPE_DESC.equals(orderType)));</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 分页方法</div><div class="line">int fromIndex = (page - 1) * perPageCount;</div><div class="line">int toIndex = page * perPageCount;</div><div class="line">if (toIndex &gt; array.size()) &#123;</div><div class="line">    toIndex = array.size();</div><div class="line">&#125;</div><div class="line"></div><div class="line">return array.subList(fromIndex, toIndex);</div></pre></td></tr></table></figure></p>
<p>注意到这里使用了门面模式，通过DruidStatManagerFacade去操作druid的核心类DruidDataSource。<br>接下来我们来看看druid是如何记录sql执行以及如何存储这些记录的。看一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public List&lt;Map&lt;String, Object&gt;&gt; getSqlStatDataList(Integer dataSourceId) &#123;</div><div class="line">        //获取数据源实例</div><div class="line">        Set&lt;Object&gt; dataSources = getDruidDataSourceInstances();</div><div class="line">        //若数据源id为空，则获取所有数据源数据</div><div class="line">        if (dataSourceId == null) &#123;</div><div class="line">            List&lt;Map&lt;String, Object&gt;&gt; sqlList = new ArrayList&lt;Map&lt;String, Object&gt;&gt;();</div><div class="line"></div><div class="line">            for (Object datasource : dataSources) &#123;</div><div class="line">                sqlList.addAll(getSqlStatDataList(datasource));</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            return sqlList;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        for (Object datasource : dataSources) &#123;</div><div class="line">            if (dataSourceId != null &amp;&amp; dataSourceId.intValue() != System.identityHashCode(datasource)) &#123;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            return getSqlStatDataList(datasource);</div><div class="line">        &#125;</div><div class="line">        // 小编觉得此处的return好像是多余的，但是增加了程序的健壮性</div><div class="line">        return new ArrayList&lt;Map&lt;String, Object&gt;&gt;();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>看到这里我们一定很好奇druid是如何维护这个dataSource的呢？<br>接下来会比较枯燥的代码，列位看官可以以个舒服的姿势看下去，最好是能有杯茶，放点枸杞是极好的。<br>我们直接进入DruidDataSource，嗯，这是一个很大很大的类，果然国内人写代码就是跟国外的不一样。<br>继续我们上面的跟踪。DruidDataSource里维护一个JdbcDataSourceStat的对象dataSourceStat来记录jdbc数据源相关信息。然后在JdbcDataSourceStat里通过LinkedHashMap<string, jdbcsqlstat="">来记录sql的执行记录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//初始化大小为16，负载因子为0.75，以插入顺序为排列顺序</div><div class="line">sqlStatMap = new LinkedHashMap&lt;String, JdbcSqlStat&gt;(16, 0.75f, false)</div></pre></td></tr></table></figure></string,></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public DruidDataSource(boolean fairLock)&#123;</div><div class="line">        super(fairLock);</div><div class="line">        //根据系统配置初始化监控内存</div><div class="line">        configFromPropety(System.getProperties());</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>现在我们知道了所有的监控记录都是放在内存里的，接下来我们来看看druid是如何监控到sql执行并放到内存里的。</p>
<h2 id="WebStatFilter"><a href="#WebStatFilter" class="headerlink" title="WebStatFilter"></a>WebStatFilter</h2><p>可能大家已经猜到了，既然数据库的状态的变化是由外部请求引起的，那么监听记录的保存肯定是对请求的追踪，接下来我们就看看WebStatFilter是如何跟踪请求执行的。<br>直接看WebStatFilter的doFilter的方法，druid对请求以及请求的session,webApp的状态，请求url进行了记录，我们没看到sql的相关实体类，进一步看WebRequestStat里有相关jdbc属性记录：<br><img src="/images/druid/druid_webRequestStat.png" alt="webRequestStat"><br>既然有这些属性必然会在执行sql的时候进行相关属性的变更，请求的执行必然会涉及连接池去连接，那么会不会在连接的通过切面之类的完成呢，考虑druid要做兼容，最有可能通过过滤器来做，有了这个思路我们在源码目录里找到了过滤器的目录，看到StatFilter，看类名我们就知道了就是对请求各种监控的更新的过滤器。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>好了，对于druid的监听就介绍到这里了，里面还有很多细节，在这里就不介绍了，因为。。。。我也没完全弄懂！！！！！，下一个我们将介绍druid的核心连接池实现。</p>
]]></content>
      
        <categories>
            
            <category> java中间件 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> druid </tag>
            
            <tag> spring-boot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring-boot里druid连接池配置（一）]]></title>
      <url>/2017/09/18/spring-boot%E9%87%8Cdruid%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>J2EE项目大部分都会涉及到数据库，为了提高操作数据库的性能，提高访问的并发量，大部分的应用会选择使用数据库连接池，目前比较成熟的数据库连接池有许多，像c3p0,dhcp等已经成为ORM中间件的标配。druid作为数据库连接池的后起之秀，号称史上性能最好的数据库连接池，逐步的被广泛应用于互联网公司项目中。今天介绍一下druid在spring-boot里的简单的使用。后续将更新druid的一些配置含义</p>
<h2 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h2><p>小编使用了druid目前支持的集成spring-boot版本，主要的maven依赖如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.1.3&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.1.1&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.2.14&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;3.1.0&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h2><p>数据库使用mysql数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">####################数据库配置-start#############################</div><div class="line">spring.datasource.druid.url=jdbc:mysql://xxxx:3306/dataBaseName?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true</div><div class="line">spring.datasource.druid.username=root</div><div class="line">#spring.datasource.druid.password=123456</div><div class="line"># 生成的加密后的密码</div><div class="line">spring.datasource.druid.password=HT+5KPmyjBjCFi3+DbO0L8epACBi+m9i6l3R1D6pllgLPPLal7m8p1blvPUijlnx8A9pYZEDmA4Bbr5K1/gNJQ==</div><div class="line"># 启用ConfigFilter</div><div class="line">spring.datasource.druid.filter.config.enabled=true</div><div class="line">spring.datasource.druid.driver-class-name=com.mysql.jdbc.Driver</div><div class="line">####################数据库连接池配置-start#######################</div><div class="line">spring.datasource.druid.initial-size=1</div><div class="line">spring.datasource.druid.max-active=20</div><div class="line">spring.datasource.druid.min-idle=1</div><div class="line">spring.datasource.druid.max-wait=50000</div><div class="line">spring.datasource.druid.pool-prepared-statements=true</div><div class="line">spring.datasource.druid.max-pool-prepared-statement-per-connection-size=20</div><div class="line">spring.datasource.druid.validation-query=select 1 from user_info</div><div class="line">spring.datasource.druid.validation-query-timeout=30000</div><div class="line">spring.datasource.druid.test-on-borrow=false</div><div class="line">spring.datasource.druid.test-on-return=false</div><div class="line">spring.datasource.druid.test-while-idle=true</div><div class="line">spring.datasource.druid.time-between-eviction-runs-millis=60000</div><div class="line">spring.datasource.druid.filters=stat,wall,log4j</div><div class="line">####################数据库连接池配置-end#########################</div></pre></td></tr></table></figure></p>
<h2 id="spring-boot初始化配置"><a href="#spring-boot初始化配置" class="headerlink" title="spring-boot初始化配置"></a>spring-boot初始化配置</h2><p>使用druid的第一个好处是它帮我们实现了简单的数据库监控，我们能监控sql执行的情况。通过配置druid自定义的filter和servlet，我们能通过浏览器查看数据库相关状态和应用sql执行情况，同时还能帮我们统计应用请求情况哦。<br>这里我们使用java代码的方式配置druid的filter和servlet，使用注解的配置莫名其妙的未生效让人很捉急。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @author xk</div><div class="line"> * @createTime 2017/9/18 0009 上午 10:47</div><div class="line"> * @description</div><div class="line"> */</div><div class="line">@Configuration</div><div class="line">public class DruidConfiguration &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 配置StatView的Servlet</div><div class="line">     */</div><div class="line">    @Bean</div><div class="line">    public ServletRegistrationBean DruidStatViewServlet()&#123;</div><div class="line">        ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(new StatViewServlet(),&quot;/druid/*&quot;);</div><div class="line">        //添加初始化参数：initParams</div><div class="line">        //白名单：</div><div class="line">        servletRegistrationBean.addInitParameter(&quot;allow&quot;, &quot;127.0.0.1&quot;);</div><div class="line">        //IP黑名单 (存在共同时，deny优先于allow) : 如果满足deny的话提示:Sorry, you are not permitted to view this page.</div><div class="line">        servletRegistrationBean.addInitParameter(&quot;deny&quot;, &quot;192.x.x.x&quot;);</div><div class="line">        //登录查看信息的账号密码.</div><div class="line">        servletRegistrationBean.addInitParameter(&quot;loginUsername&quot;, &quot;admin&quot;);</div><div class="line">        servletRegistrationBean.addInitParameter(&quot;loginPassword&quot;, &quot;123456&quot;);</div><div class="line">        //是否能够重置数据.</div><div class="line">        servletRegistrationBean.addInitParameter(&quot;resetEnable&quot;, &quot;false&quot;);</div><div class="line">        return servletRegistrationBean;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 配置statView的Filter</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    @Bean</div><div class="line">    public FilterRegistrationBean druidStatFilter()&#123;</div><div class="line">        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(new WebStatFilter());</div><div class="line"></div><div class="line">        //添加过滤规则.</div><div class="line">        filterRegistrationBean.addUrlPatterns(&quot;/*&quot;);</div><div class="line"></div><div class="line">        //添加不需要忽略的格式信息.</div><div class="line">        filterRegistrationBean.addInitParameter(&quot;exclusions&quot;, &quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&quot;);</div><div class="line">        //添加数据库sql监控</div><div class="line">        filterRegistrationBean.addInitParameter(&quot;profileEnable&quot;,&quot;true&quot;);</div><div class="line">        return filterRegistrationBean;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然大家别忘了数据源的配置和mybatis的配置，这里我不做介绍。</p>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>应用跑起来，浏览器输入localhost:port/druid/,就会进入登录页，输入账号密码，即可进入首页，如下图：<br><img src="/images/druid/druid_index_view.png" alt="druid监控页图"></p>
<h2 id="数据库安全配置"><a href="#数据库安全配置" class="headerlink" title="数据库安全配置"></a>数据库安全配置</h2><p>使用druid的第二个好处就是实现了密文的数据库账号密码配置的加密,废话不多说，我们来看看怎么对我们的密码进行加密。<br>cmd到druid的jar包目录下，执行：java -cp druid-1.1.3.jar com.alibaba.druid.filter.config.ConfigTools you_password<br><img src="/images/druid/druid_password.png" alt="druid密码加密"><br>这里取public-key作为解密公钥，password即为加密后的密码。<br>配置文件里修改配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">spring.datasource.druid.password=HT+5KPmyjBjCFi3+DbO0L8epACBi+m9i6l3R1D6pllgLPPLal7m8p1blvPUijlnx8A9pYZEDmA4Bbr5K1/gNJQ==</div></pre></td></tr></table></figure></p>
<p>添加公钥配置和启用使用加密方法的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//生成的公钥</div><div class="line">public-key=MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAMIQ1SdCmGJlswLkNvh5rpySGPxZXr9bfFei5J4h7/q9XVlqePLcOTVkyQ0je4Gnnp2ZQPlCBsAo5ZPEXJShgRUCAwEAAQ==</div><div class="line">//配置 connection-properties，启用加密，配置公钥。</div><div class="line">spring.datasource.druid.connection-properties=config.decrypt=true;config.decrypt.key=$&#123;public-key&#125;</div></pre></td></tr></table></figure></p>
<p>启用configfilter，使加密生效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">spring.datasource.druid.filter.config.enabled=true</div></pre></td></tr></table></figure></p>
<p>详细代码：<a href="https://github.com/xkupc/druid-spring-boot" target="_blank" rel="external">https://github.com/xkupc/druid-spring-boot</a><br>参考内容：<a href="https://github.com/alibaba/druid" target="_blank" rel="external">https://github.com/alibaba/druid</a>  <a href="https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter" target="_blank" rel="external">https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter</a></p>
]]></content>
      
        <categories>
            
            <category> java中间件 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> druid </tag>
            
            <tag> spring-boot </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
