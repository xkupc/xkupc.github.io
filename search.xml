<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[简单爬虫（一）]]></title>
      <url>/%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>荒废的时光。。。。。果然有些东西真的是一时心血来潮，坚持真的很重要的。最近也是心血来潮，研究了一下网络爬虫的套路。其实很简单，就是模拟http请求网页，然后获取静态的html字符串，使用解析工具解析html获取你想要的结果。我不知道说的对不对，可能真正写爬虫的会觉得这种想法是很low。我也想了解更深次的爬虫，可以一直爬的爬虫，什么深度遍历广度遍历算法，异步解析啊，这里面学问很深。不过不要紧，慢慢来，万丈高楼平地起，由简入难，坚持，总有一天你会成功的。</p>
<h3 id="简单爬虫-获取腾讯视频vip视频url"><a href="#简单爬虫-获取腾讯视频vip视频url" class="headerlink" title="简单爬虫-获取腾讯视频vip视频url"></a>简单爬虫-获取腾讯视频vip视频url</h3><p>最先接触爬虫，我能想到的就是获取静态页的视频url.所以就拿腾讯视频练练手。前面也说了，我的方法很简单就是模拟http请求，然后解析html。<br><a id="more"></a></p>
<h3 id="HttpClients"><a href="#HttpClients" class="headerlink" title="HttpClients"></a>HttpClients</h3><p>模拟http请求，我用了最简单的apache的httpclient包。依赖如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;httpclient&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p>
<p>因为是用springboot集成的，我用是springboot1.5.3，它依赖的httpclient版本是4.5.3。</p>
<h3 id="jsoup"><a href="#jsoup" class="headerlink" title="jsoup"></a>jsoup</h3><p>通过httpGet请求获取到返回结果后，我们就需要对返回结果对解析，从中提取我们想要的视频url。这里我用了爬虫大神都会用的jsoup工具。依赖如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.jsoup&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;jsoup&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.10.3&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p>
<p>我们先看看腾讯视频的视频地址的静态页：<br><img src="images/crawler/videoUrl.png" alt="视频url"><br>点开其中一个item，我们可以看到里面包括了视频的url，视频的头像url，视频的描述，评分，大家看有mark_v的clsaa，那是视频的一个标签，表示vip,用劵，付费等观看条件。知道这些以后那很简单，我们通过jsoup提供的select方法获取标签元素，在遍历元素，获取元素的属性等信息，就拿到了我们想要的结果了。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>源码我就不贴了，有兴趣到我github上去看看，写的很low,还需要优化。</p>
]]></content>
      
        <categories>
            
            <category> springboot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> spring-boot </tag>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[springboot单元测试的默认配置]]></title>
      <url>/springboot%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近根据<a href="https://tech.meituan.com/MT_Leaf.html" target="_blank">Leaf——美团点评分布式ID生成系统</a>中Leaf-snowflake方案的思路，实现了一个简单版本的分布式ID生成方法。在这过程中遇到了一些问题，在这里把问题记下来，当个错题集吧，觉得low的看官，请勿拍砖。因为只是一个简单的生成id方法，我并未想着去将之做成单个服务，而是一个工具包的形式，让有需求的应用系统依赖这个包。所以这个时候就要考虑单个系统部署集群的时候在zookeeper里的节点如何配置。于是我能想到了是根据ip和端口号去唯一标示集群里的单个服务。然后我们的问题来了。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当我在Springboot的配置文件里配置服务的端口号，然后单元测试的时候，却怎么也获取不到这个端口号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">he application.properties:</div><div class="line">server.port = 30008</div><div class="line"></div><div class="line">@RunWith(SpringJUnit4ClassRunner.class)</div><div class="line">@SpringApplicationConfiguration(CustomerCenterApplication.class)</div><div class="line">@WebAppConfiguration</div><div class="line">public class BaseTestService &#123;</div><div class="line">@Value(&quot;$&#123;server.port&#125;&quot;)</div><div class="line">String serverPort;</div><div class="line">@Test</div><div class="line">public void test()&#123;</div><div class="line">System.out.println(serverPort);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>打印的结果很让人意外，是-1，而不是null之类的。在这个问题是纠结了一天之后，我选择升级springboot的版本，采用1.4.0以上的版本,采用以下的代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@RunWith(SpringJUnit4ClassRunner.class)</div><div class="line">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)</div><div class="line">public class BaseTestService &#123;</div><div class="line">@Value(&quot;$&#123;local.server.port&#125;&quot;)或者@LocalServerPort</div><div class="line">String serverPort;</div><div class="line">@Test</div><div class="line">public void test()&#123;</div><div class="line">System.out.println(serverPort);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>很神奇，可是为什么呢，还是那句话，源码不会骗人。既然是配置的问题，我们来看看Springboot启动测试的时候是如何加载配置的，我们立马想到@SpringApplicationConfiguration这个注解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@ContextConfiguration(loader = SpringApplicationContextLoader.class)</div><div class="line">@Documented</div><div class="line">@Inherited</div><div class="line">@Retention(RetentionPolicy.RUNTIME)</div><div class="line">@Target(ElementType.TYPE)</div><div class="line">public @interface SpringApplicationConfiguration &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到通过这个注解，springboot加载了一个SpringApplicationContextLoader来完成上下文的配置加载。我们来看看这个loader做了些什么事。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">	public ApplicationContext loadContext(final MergedContextConfiguration config)</div><div class="line">			throws Exception &#123;</div><div class="line">		assertValidAnnotations(config.getTestClass());</div><div class="line">		SpringApplication application = getSpringApplication();</div><div class="line">		application.setMainApplicationClass(config.getTestClass());</div><div class="line">		application.setSources(getSources(config));</div><div class="line">		ConfigurableEnvironment environment = new StandardEnvironment();</div><div class="line">		if (!ObjectUtils.isEmpty(config.getActiveProfiles())) &#123;</div><div class="line">			setActiveProfiles(environment, config.getActiveProfiles());</div><div class="line">		&#125;</div><div class="line">		Map&lt;String, Object&gt; properties = getEnvironmentProperties(config);</div><div class="line">		addProperties(environment, properties);</div><div class="line">		...</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>我们看到 通过getEnvironmentProperties(config)获取配置文件配置信息，然后放到environment里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">protected Map&lt;String, Object&gt; getEnvironmentProperties(</div><div class="line">		MergedContextConfiguration config) &#123;</div><div class="line">	Map&lt;String, Object&gt; properties = new LinkedHashMap&lt;String, Object&gt;();</div><div class="line">	// JMX bean names will clash if the same bean is used in multiple contexts</div><div class="line">	disableJmx(properties);</div><div class="line">	properties.putAll(TestPropertySourceUtils</div><div class="line">			.convertInlinedPropertiesToMap(config.getPropertySourceProperties()));</div><div class="line">	if (!TestAnnotations.isIntegrationTest(config)) &#123;</div><div class="line">		properties.putAll(getDefaultEnvironmentProperties());</div><div class="line">	&#125;</div><div class="line">	return properties;</div><div class="line">&#125;</div><div class="line"></div><div class="line">   private Map&lt;String, String&gt; getDefaultEnvironmentProperties() &#123;</div><div class="line">	return Collections.singletonMap(&quot;server.port&quot;, &quot;-1&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>真想是如此简单。在最新的Springboot版本里这个方法改动很大，但依旧默认将端口设置为-1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">protected String[] getInlinedProperties(MergedContextConfiguration config) &#123;</div><div class="line">        ArrayList&lt;String&gt; properties = new ArrayList();</div><div class="line">        this.disableJmx(properties);</div><div class="line">        properties.addAll(Arrays.asList(config.getPropertySourceProperties()));</div><div class="line">        if (!this.isEmbeddedWebEnvironment(config) &amp;&amp; !this.hasCustomServerPort(properties)) &#123;</div><div class="line">            properties.add(&quot;server.port=-1&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return (String[])properties.toArray(new String[properties.size()]);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>想想大概是测试的时候不对外暴露服务吧。</p>
]]></content>
      
        <categories>
            
            <category> person idea </category>
            
        </categories>
        
        
        <tags>
            
            <tag> spring-boot </tag>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[并发编程里的一些概念（一）]]></title>
      <url>/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%87%8C%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前阵子，研究了一下分布式唯一ID的生成方法，接触了多线程的一些东西，发现自己对并发编程的一些基础概念还是一无所知，对于并发的控制还是停留在synchronized的层面，简直不能再低级了，小编可是要成为架构师的男人，怎么可以如此堕落。于是可劲各种谷歌了。今天做一点基础的入门笔记，简单介绍一下多线程编程里的一些概念。</p>
<h2 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h2><p>从最基本的开始，我们知道线程最基本的实现有两种。实现Runable接口和继承Thread重写run方法。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class MyThread1 extends Thread &#123;</div><div class="line"></div><div class="line">    public void run() &#123;</div><div class="line">        System.out.println(&quot;this is myThread1&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public class MyThread2 implements Runnable&#123;</div><div class="line">    public void run() &#123;</div><div class="line">        System.out.println(&quot;this is myThread2&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Test</div><div class="line">    public void threadTest() &#123;</div><div class="line">        Thread thread1 = new MyThread1();</div><div class="line">        Thread thread2 = new Thread(new MyThread2());</div><div class="line">        thread1.start();</div><div class="line">        thread2.start();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在JDK1.5后我们有第三种方法实现，那就是实现Callable接口,Callable和Runable区别主要是Callable的call方法有返回值同时能抛出异常，而Runable的run方法没有。同时运行Callable任务能够拿到一个Future对象，通过Future对象我们可以检查任务是否完成，检索任务执行的结果，同时可以取消任务的执行，弥补了Thread的不足。<br>Callable无法通过new Thread(Runable r)来实现。通常我们可以通过FutureTask来实现，FutureTask实现了Runnable和Future，使得我们依旧能通过Thread启动线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class MyThread3 implements Callable&lt;Boolean&gt; &#123;</div><div class="line">    public Boolean call() throws Exception &#123;</div><div class="line">        System.out.println(&quot;this is myThread3&quot;);</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@Test</div><div class="line">    public void threadTest() &#123;</div><div class="line">        Thread thread1 = new MyThread1();</div><div class="line">        Thread thread2 = new Thread(new MyThread2());</div><div class="line">        FutureTask&lt;Boolean&gt; futureTask = new FutureTask&lt;Boolean&gt;(new MyThread3());</div><div class="line">        Thread thread3 = new Thread(futureTask);</div><div class="line">        thread1.start();</div><div class="line">        thread2.start();</div><div class="line">        thread3.start();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>当然我们也可以通过ExecutorService来实现，ExecutorService是线程池里一个概念。我们接着看看线程池的实现。</p>
<h2 id="线程池的实现"><a href="#线程池的实现" class="headerlink" title="线程池的实现"></a>线程池的实现</h2><p>在java 5之后，java.util.concurrent里提供了现成的线程池的实现。这个包里的线程的类图：<br><img src="/images/thread/Executor.png" alt="Executor"><br>看看相关的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public interface Executor &#123;</div><div class="line">    void execute(Runnable command);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public interface ExecutorService extends Executor &#123;</div><div class="line">    void shutdown();</div><div class="line">    List&lt;Runnable&gt; shutdownNow();</div><div class="line"></div><div class="line">    boolean isShutdown();</div><div class="line">    boolean isTerminated();</div><div class="line"></div><div class="line">    &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</div><div class="line">    &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</div><div class="line">    Future&lt;?&gt; submit(Runnable task);</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Executors &#123;</div><div class="line">    public static ExecutorService newCachedThreadPool() &#123;</div><div class="line">            return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, </div><div class="line">                            new SynchronousQueue&lt;Runnable&gt;());</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到ExecutorService通过继承Executor定义了一个线程池，默认线程池实现是ThreadPoolExecutor。我们可以通过Executors创建线程池。<br>Executors里提供了四种线程池的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//创建一个固定大小的线程池，每次任务从线程池中获取一个空闲线程来执行任务，若无空闲线程则创建新的线程直到线程数达到线程池的最大大小。一旦线程数达到最大数，保持大小不变，在有任务进来则等待线程空闲</div><div class="line">newFixedThreadPool(int nThreads);</div><div class="line">//创建一个单线程的线程池，即只有一个线程的线程池，所有的任务都串行执行。想不出这个线程的作用，顺序执行意味着可以使任务的执行顺序按照任务提交顺序执行。</div><div class="line">newSingleThreadExecutor();</div><div class="line">//创建一个可根据需要创建新线程的线程池，没有固定的大小，但是可以像newFixedThreadPool一样创建新的线程。</div><div class="line">//其实是有线程数的限制（最大线程数为Integer.MAX_VALUE，在初始化的时候默认设定的），它会将那些已有超过设定的超时时间未被使用的线程从池中移除，估计在高并发情况下使用这个可能会有内存溢出的异常</div><div class="line">newCachedThreadPool();</div><div class="line">//创建一个大小无限的线程池(这个估计和newCachedThreadPool一样也设定了默认最大线程数)，此线程池支持定时以及周期性执行任务的需求。</div><div class="line">newScheduledThreadPool();</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> java base </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[神奇的springboot注解]]></title>
      <url>/%E7%A5%9E%E5%A5%87%E7%9A%84springboot%E6%B3%A8%E8%A7%A3.html</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>小编接触springboot的时间很短，平时也就拿着已经成熟的框架，写着无关痛痒的业务代码，在看druid的源码的时候，涉猎了很多注解，发现通过简单的一个注解，使大量的配置属性初始化到bean里，对我这种还停留在@value级别的小白来说简直大开眼界了。今天想着介绍一下springboot里我刚刚学到的几个厉害的注解。</p>
<h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><p>在介绍厉害的之前我们先来入个门，这个注解在spring里就已经存在了，是spring用来替代通过xml配置bean的繁琐方式的。在spring里使用这个注解，我们需要在xml里指定扫描的路径，而在springboot里我们就完全不用指定，只要保证springboot启动入口的路径包含了注解所在的包就可以了。在springboot里这个注解一般用来在系统启动时初始化系统数据源，数据库中间件等一些系统配置项。<br>下面我们通过一个例子来看看：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">@Configuration</div><div class="line">public class UserConfig &#123;</div><div class="line">    @Value(&quot;$&#123;user.name&#125;&quot;)</div><div class="line">    private String userName;</div><div class="line">    @Value(&quot;$&#123;user.age&#125;&quot;)</div><div class="line">    private int userAge;</div><div class="line">    @Value(&quot;$&#123;user.cityId&#125;&quot;)</div><div class="line">    private String cityId;</div><div class="line">    @Value(&quot;$&#123;user.proviceId&#125;&quot;)</div><div class="line">    private String proviceId;</div><div class="line"></div><div class="line">    @Bean</div><div class="line">    public BaseModel baseModel()&#123;</div><div class="line">        BaseModel baseModel = new BaseModel();</div><div class="line">        baseModel.setUserName(userName);</div><div class="line">        baseModel.setUserAge(userAge);</div><div class="line">        baseModel.setCityId(cityId);</div><div class="line">        baseModel.setProviceId(proviceId);</div><div class="line">        return baseModel;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">    //测试</div><div class="line">    @Autowired</div><div class="line">    BaseModel baseModel;</div><div class="line"></div><div class="line">    @Test</div><div class="line">    public void getBaseModel()&#123;</div><div class="line">        System.out.println(baseModel.toString);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>很简单的demo，结果是baseModel按配置文件初始化了。</p>
<h2 id="ConfigurationProperties、EnableConfigurationProperties"><a href="#ConfigurationProperties、EnableConfigurationProperties" class="headerlink" title="ConfigurationProperties、EnableConfigurationProperties"></a>ConfigurationProperties、EnableConfigurationProperties</h2><p>有了上面Configuration的基础，我们来看看ConfigurationProperties是做了些啥呢。<br>修改一下baseModel实体类和UserConfig配置类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">//使用ConfigurationProperties注解，设置配置文件里关联属性的key的前缀</div><div class="line">@ConfigurationProperties(prefix = &quot;user&quot;)</div><div class="line">public class BaseModel&#123;</div><div class="line">    private String userName;</div><div class="line">    private int userAge;</div><div class="line">    private String cityId;</div><div class="line">    private String proviceId;</div><div class="line"></div><div class="line">    public String getUserName() &#123;</div><div class="line">        return userName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setUserName(String userName) &#123;</div><div class="line">        this.userName = userName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getUserAge() &#123;</div><div class="line">        return userAge;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setUserAge(int userAge) &#123;</div><div class="line">        this.userAge = userAge;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getCityId() &#123;</div><div class="line">        return cityId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setCityId(String cityId) &#123;</div><div class="line">        this.cityId = cityId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getProviceId() &#123;</div><div class="line">        return proviceId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setProviceId(String proviceId) &#123;</div><div class="line">        this.proviceId = proviceId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return &quot;BaseModel&#123;&quot; +</div><div class="line">                &quot;userName=&apos;&quot; + userName + &apos;\&apos;&apos; +</div><div class="line">                &quot;, userAge=&quot; + userAge +</div><div class="line">                &quot;, cityId=&apos;&quot; + cityId + &apos;\&apos;&apos; +</div><div class="line">                &quot;, proviceId=&apos;&quot; + proviceId + &apos;\&apos;&apos; +</div><div class="line">                &apos;&#125;&apos;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//UserConfig配置类</div><div class="line">//这里还是使用Configuration初始化配置</div><div class="line">@Configuration</div><div class="line">//对BaseModel启用ConfigurationProperties，如果没有这个，默认不开启，那么在测试类里用Autowired就会报错</div><div class="line">@EnableConfigurationProperties(BaseModel.class)</div><div class="line">public class UserConfig &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试结果依旧是baseModel按配置初始化成功<br>当我把baseModel里的get、set方法删除时，就初始化不了，很明显，这里依旧还是反射，看官们可能觉得你也可以这么做，容我贴一下我的配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">user.user-name = test</div><div class="line">user.user-age = 12</div><div class="line">user.cityId = 330600</div><div class="line">user.proviceId =331000</div></pre></td></tr></table></figure></p>
<p>就问你惊不惊喜，意不意外。属性的key与baseModel里的属性名没有直接映射，springboot支持“-”别名映射。如果我在baseModel里增加另一个类的依赖呢。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//在BaseModel里新增一个实体类属性</div><div class="line">private UserCompany workCompany;</div><div class="line"></div><div class="line">//配置文件新增属性</div><div class="line">user.work-company.company-name = 凯歌集团</div><div class="line">user.work-company.companyPhone = 123456</div><div class="line"></div><div class="line">//测试用例修改</div><div class="line"> @Autowired</div><div class="line">  BaseModel baseModel;</div><div class="line"></div><div class="line">  @Test</div><div class="line">  public void getBaseModel()&#123;</div><div class="line">      System.out.println(baseModel.toString());</div><div class="line">      System.out.println(baseModel.getWorkCompany().toString());</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>依旧初始化成功。是时候看一波源码了。<br>打开EnableConfigurationProperties，我可以看到他引入一个EnableConfigurationPropertiesImportSelector,接下来我们看看这个Selector都做了些啥<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public String[] selectImports(AnnotationMetadata metadata) &#123;</div><div class="line">		MultiValueMap&lt;String, Object&gt; attributes = metadata.getAllAnnotationAttributes(</div><div class="line">				EnableConfigurationProperties.class.getName(), false);</div><div class="line">        // 获取注解EnableConfigurationProperties里配置的class</div><div class="line">		Object[] type = attributes == null ? null</div><div class="line">				: (Object[]) attributes.getFirst(&quot;value&quot;);</div><div class="line">		if (type == null || type.length == 0) &#123;</div><div class="line">			return new String[] &#123;</div><div class="line">					ConfigurationPropertiesBindingPostProcessorRegistrar.class</div><div class="line">							.getName() &#125;;</div><div class="line">		&#125;</div><div class="line">        //按demo里的例子，我们配置了@EnableConfigurationProperties(BaseModel.class)</div><div class="line">        //则将ConfigurationPropertiesBeanRegistrar和ConfigurationPropertiesBindingPostProcessorRegistrar</div><div class="line">        //完成BaseModel与配置属性的映射</div><div class="line">		return new String[] &#123; ConfigurationPropertiesBeanRegistrar.class.getName(),</div><div class="line">				ConfigurationPropertiesBindingPostProcessorRegistrar.class.getName() &#125;;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>我们看ConfigurationPropertiesBeanRegistrar里的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public void registerBeanDefinitions(AnnotationMetadata metadata,</div><div class="line">				BeanDefinitionRegistry registry) &#123;</div><div class="line">			MultiValueMap&lt;String, Object&gt; attributes = metadata</div><div class="line">					.getAllAnnotationAttributes(</div><div class="line">							EnableConfigurationProperties.class.getName(), false);</div><div class="line">			List&lt;Class&lt;?&gt;&gt; types = collectClasses(attributes.get(&quot;value&quot;));</div><div class="line">			for (Class&lt;?&gt; type : types) &#123;</div><div class="line">				String prefix = extractPrefix(type);</div><div class="line">				String name = (StringUtils.hasText(prefix) ? prefix + &quot;-&quot; + type.getName()</div><div class="line">						: type.getName());</div><div class="line">				if (!containsBeanDefinition((ConfigurableListableBeanFactory) registry,</div><div class="line">						name)) &#123;</div><div class="line">                    //实际上只做了一件事就是如果配置类（demo里的BaseModel）未被注入容器，则完成配置类的注入</div><div class="line">					registerBeanDefinition(registry, type, name);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
<p>ConfigurationPropertiesBindingPostProcessorRegistrar里的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,</div><div class="line">			BeanDefinitionRegistry registry) &#123;</div><div class="line">		if (!registry.containsBeanDefinition(BINDER_BEAN_NAME)) &#123;</div><div class="line">			BeanDefinitionBuilder meta = BeanDefinitionBuilder</div><div class="line">					.genericBeanDefinition(ConfigurationBeanFactoryMetaData.class);</div><div class="line">            //这里注入了ConfigurationPropertiesBindingPostProcessor完成属性与配置的绑定</div><div class="line">			BeanDefinitionBuilder bean = BeanDefinitionBuilder.genericBeanDefinition(</div><div class="line">					ConfigurationPropertiesBindingPostProcessor.class);</div><div class="line">			bean.addPropertyReference(&quot;beanMetaDataStore&quot;, METADATA_BEAN_NAME);</div><div class="line">			registry.registerBeanDefinition(BINDER_BEAN_NAME, bean.getBeanDefinition());</div><div class="line">			registry.registerBeanDefinition(METADATA_BEAN_NAME, meta.getBeanDefinition());</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>接下来我们看看ConfigurationPropertiesBindingPostProcessor是怎么实现绑定的。查看了<a href="https://docs.spring.io/spring-boot/docs/1.4.7.RELEASE/api/" target="_blank">springboot的官方api</a>,我们可以看到这样一句话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BeanPostProcessor to bind PropertySources to beans annotated with ConfigurationProperties.</div></pre></td></tr></table></figure></p>
<p>通过BeanPostProcessor接口实现配置资源和实体类的绑定。在ConfigurationPropertiesBindingPostProcessor的方法中，我们只要找到实现了BeanPostProcessor的方法即可找到绑定的实现。ok，我们看到BeanPostProcessor有postProcessBeforeInitialization和postProcessAfterInitialization方法，看方法名我们大概有个模糊的认识，应该是在bean初始化前后的操作。我们看postProcessBeforeInitialization这个方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">private void postProcessBeforeInitialization(Object bean, String beanName, ConfigurationProperties annotation) &#123;</div><div class="line">        PropertiesConfigurationFactory&lt;Object&gt; factory = new PropertiesConfigurationFactory(bean);</div><div class="line">        factory.setPropertySources(this.propertySources);</div><div class="line">        factory.setValidator(this.determineValidator(bean));</div><div class="line">        factory.setConversionService(this.conversionService == null ? this.getDefaultConversionService() : this.conversionService);</div><div class="line">        if (annotation != null) &#123;</div><div class="line">            factory.setIgnoreInvalidFields(annotation.ignoreInvalidFields());</div><div class="line">            factory.setIgnoreUnknownFields(annotation.ignoreUnknownFields());</div><div class="line">            factory.setExceptionIfInvalid(annotation.exceptionIfInvalid());</div><div class="line">            factory.setIgnoreNestedProperties(annotation.ignoreNestedProperties());</div><div class="line">            if (StringUtils.hasLength(annotation.prefix())) &#123;</div><div class="line">                factory.setTargetName(annotation.prefix());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            //很明显，经过一系列校验后，通过加载配置的工厂类完成配置和属性的绑定</div><div class="line">            factory.bindPropertiesToTarget();</div><div class="line">        &#125; catch (Exception var8) &#123;</div><div class="line">            String targetClass = ClassUtils.getShortName(bean.getClass());</div><div class="line">            throw new BeanCreationException(beanName, &quot;Could not bind properties to &quot; + targetClass + &quot; (&quot; + this.getAnnotationDetails(annotation) + &quot;)&quot;, var8);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>好了，ConfigurationProperties就介绍到这里了，中间还有许多不明白的，源码看的很吃力，还需慢慢努力。属性和配置名不一致也能绑定成功，估计是反射的时候，对配置名做了处理。</p>
]]></content>
      
        <categories>
            
            <category> java framework </category>
            
        </categories>
        
        
        <tags>
            
            <tag> spring-boot </tag>
            
            <tag> spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring-boot里druid连接池配置（三）]]></title>
      <url>/spring-boot%E9%87%8Cdruid%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%89%EF%BC%89.html</url>
      <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>上一篇我们知道druid实现监控的大致原理，今天我们学习一下，druid数据库连接池的实现。</p>
<h3 id="数据库连接池配置"><a href="#数据库连接池配置" class="headerlink" title="数据库连接池配置"></a>数据库连接池配置</h3><p>首先我们来看一下数据库数据源的初始化配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 主数据源</div><div class="line"> */</div><div class="line"></div><div class="line">@Bean(name = &quot;primaryDataSource&quot;)</div><div class="line">@Primary</div><div class="line">@ConfigurationProperties(prefix = &quot;spring.datasource.druid&quot;)</div><div class="line">public DataSource primaryDataSource() &#123;</div><div class="line">    return DruidDataSourceBuilder.create().build();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>获取spring.datasource.druid前缀的相关配置属性，初始化数据源。我们来看看druid为适配springboot开发的druid-spring-boot-starter都做了哪些事。<br><img src="/images/druid/druid-spring-boot-starter.png" alt="druid-spring-boot-starter代码结构"><br>从图中我们看到，这个包很简单，主要做了两个事，一个是通过springboot的数据源初始化机制初始化自己的数据源，通过DruidDataSourceWrapper兼容springboot的数据源配置，第二个是通过springboot的注解机制，通过配置初始化自定义的系列Filter。<br>是的，我们也可以通过配置文件配置我们上篇文章提到的statViewServlet和webStatFilter。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//初始化statViewServlet</div><div class="line">spring.datasource.druid.stat-view-servlet.enabled</div><div class="line">//初始化webStatFilter</div><div class="line">spring.datasource.druid.web-stat-filter.enabled</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>看这里，这个类完成了所有配置的初始化。<br><img src="images/druid/druid_starter.png" alt="druid初始化配置"><br>DruidStatProperties这个类加载了statViewServlet和webStatFilter的配置属性，然后分别通过DruidStatViewServletConfiguration和DruidWebStatFilterConfiguration以spring注册bean的方式完成注册，与我们直接通过代码的方式注册一样。<br>DataSourceProperties这个则加载了数据源的配置属性，然后通过DataSourceAutoConfiguration完成数据源初始化。<br>DruidDataSourceWrapper则完成了数据库连接池相关的配置，我们看到它继承了DruidDataSource。</p>
<h3 id="数据库连接池初始化"><a href="#数据库连接池初始化" class="headerlink" title="数据库连接池初始化"></a>数据库连接池初始化</h3><p>druid通过springboot加载完配置后，连接池是如何初始化的呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public DruidDataSource(boolean fairLock)&#123;</div><div class="line">     super(fairLock);</div><div class="line"></div><div class="line">     configFromPropety(System.getProperties());</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>看这里，有一个公平锁的概念，小编马上先谷歌了一下公平锁的概念，公平锁是为了解决cpu调度线程的时候随机选择线程，无法保证线程先到先得，从而导致某些优先级低的线程永远也无法获得cpu资源的问题。公平锁能够保证线程按照时间的先后顺序执行。既然要按顺序执行，那么就要维护一个有序的队列，这个开销就有点大了，果然公平是不容易实现的。druid默认是非公平锁。</p>
]]></content>
      
        <categories>
            
            <category> java中间件 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> druid </tag>
            
            <tag> spring-boot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring-boot里druid连接池配置（二）]]></title>
      <url>/spring-boot%E9%87%8Cdruid%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%85%8D%E7%BD%AE%EF%BC%88%E4%BA%8C%EF%BC%89.html</url>
      <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>上篇我们简单介绍了druid的简单配置，利用druid实现了数据库的监控和配置密码的加密，今天我们从源码的角度分析druid的监控实现。</p>
<h3 id="数据库监控配置"><a href="#数据库监控配置" class="headerlink" title="数据库监控配置"></a>数据库监控配置</h3><p>在上篇的代码里我们通过springboot自带的Servlet注册Bean进行Servlet注册了StatViewServlet，通过自带的Filter注册bean注册了WebStatFilter，今天我们俩介绍一下这个两个bean的作用。</p>
<h2 id="StatViewServlet"><a href="#StatViewServlet" class="headerlink" title="StatViewServlet"></a>StatViewServlet</h2><p>看看它的配置，我们就知道，它是一个实现druid监控视图的servlet,通过这个servlet我们配置了监控视图web页的登录账号和密码，通过设置黑白名单ip配置web页的访问权限,接下来我们来看看这个配置在哪生效的。<br>跟踪StatViewServlet的父类ResourceServlet:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">private void initAuthEnv() &#123;</div><div class="line">       String paramUserName = getInitParameter(PARAM_NAME_USERNAME);</div><div class="line">       if (!StringUtils.isEmpty(paramUserName)) &#123;</div><div class="line">           this.username = paramUserName;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       String paramPassword = getInitParameter(PARAM_NAME_PASSWORD);</div><div class="line">       if (!StringUtils.isEmpty(paramPassword)) &#123;</div><div class="line">           this.password = paramPassword;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       String paramRemoteAddressHeader = getInitParameter(PARAM_REMOTE_ADDR);</div><div class="line">       if (!StringUtils.isEmpty(paramRemoteAddressHeader)) &#123;</div><div class="line">           this.remoteAddressHeader = paramRemoteAddressHeader;</div><div class="line">       &#125;</div><div class="line">       ....</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>可以看到通过initAuthEnv完成我们配置参数的初始化工作。接着我们来看看配置怎么生效的，既然是servlet，那必然会有service方法。很快我们在ResourceServlet里找到了service方法，我们来看看druid的登陆：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">if (&quot;/submitLogin&quot;.equals(path)) &#123;</div><div class="line">           String usernameParam = request.getParameter(PARAM_NAME_USERNAME);</div><div class="line">           String passwordParam = request.getParameter(PARAM_NAME_PASSWORD);</div><div class="line">           if (username.equals(usernameParam) &amp;&amp; password.equals(passwordParam)) &#123;</div><div class="line">               request.getSession().setAttribute(SESSION_USER_KEY, username);</div><div class="line">               response.getWriter().print(&quot;success&quot;);</div><div class="line">           &#125; else &#123;</div><div class="line">               response.getWriter().print(&quot;error&quot;);</div><div class="line">           &#125;</div><div class="line">           return;</div><div class="line">       &#125;</div></pre></td></tr></table></figure></p>
<p>这里druid简单的实现了一个登陆操作，将用户名作为一个session存储。当然作为一个内部使用的web页，我们不该有太多的苛求。接下来我们看看这个service还做了什么，我们看到service承担了整个监控视图的所有请求的处理和分发，对于数据库监控数据的请求，比如sql监控数据请求<a href="http://localhost:31009/druid/sql.json?orderBy=SQL&amp;orderType=desc&amp;page=1&amp;perPageCount=1000000&amp;" target="_blank" rel="external">http://localhost:31009/druid/sql.json?orderBy=SQL&amp;orderType=desc&amp;page=1&amp;perPageCount=1000000&amp;</a> 我们看druid是如何处理的呢，我们注意到这行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">if (path.contains(&quot;.json&quot;)) &#123;</div><div class="line">           String fullUrl = path;</div><div class="line">           if (request.getQueryString() != null &amp;&amp; request.getQueryString().length() &gt; 0) &#123;</div><div class="line">               fullUrl += &quot;?&quot; + request.getQueryString();</div><div class="line">           &#125;</div><div class="line">           response.getWriter().print(process(fullUrl));</div><div class="line">           return;</div><div class="line">       &#125;</div></pre></td></tr></table></figure></p>
<p>当所有包含.json请求的都会通过process方法来处理，小编突然觉得druid对url的处理实在是好简单，突然明白为嘛它作为一个数据库连接池，还要搞一个EncodingConvertFilter的过滤器了，大公司套路深，我要回农村。。。。<br>直接看process方法，我们在StatViewServlet找到了process方法，这个厉害了，druid还可以通过配置jmx连接地址，来监控远程druid服务。也就说我们可以将实现druid连接池的应用和监控视图的web应用分离，毕竟让一个内管后台直接访问生产机器还是有风险的。<br>继续跟踪我们发现所有的请求都是通过DruidStatService.service(url)进行处理的.我们来看看druid是否处理我们上面那个请求的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (url.startsWith(&quot;/sql.json&quot;)) &#123;</div><div class="line">          return returnJSONResult(RESULT_CODE_SUCCESS, getSqlStatDataList(parameters));</div><div class="line">      &#125;</div></pre></td></tr></table></figure></p>
<p>跟踪getSqlStatDataList方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">private List&lt;Map&lt;String, Object&gt;&gt; getSqlStatDataList(Map&lt;String, String&gt; parameters) &#123;</div><div class="line">       Integer dataSourceId = null;</div><div class="line"></div><div class="line">       String dataSourceIdParam = parameters.get(&quot;dataSourceId&quot;);</div><div class="line">       if (dataSourceIdParam != null &amp;&amp; dataSourceIdParam.length() &gt; 0) &#123;</div><div class="line">           dataSourceId = Integer.parseInt(dataSourceIdParam);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       List&lt;Map&lt;String, Object&gt;&gt; array = statManagerFacade.getSqlStatDataList(dataSourceId);</div><div class="line">       List&lt;Map&lt;String, Object&gt;&gt; sortedArray = comparatorOrderBy(array, parameters);</div><div class="line">       return sortedArray;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>这里有一个dataSourceId请求里是没有的，因为我们使用的是单数据源。<br>我们看到拿到请求结果后，druid对结果进行了排序和分页，我们学习下是如何排序和分页的。这里给我们一点在内存分页的启示了吧，不过话说页面把记录总数写死的做法这样真的好么，还好有重置选项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 排序方法</div><div class="line">if (orderBy.trim().length() != 0) &#123;</div><div class="line">    Collections.sort(array, new MapComparator&lt;String, Object&gt;(orderBy, ORDER_TYPE_DESC.equals(orderType)));</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 分页方法</div><div class="line">int fromIndex = (page - 1) * perPageCount;</div><div class="line">int toIndex = page * perPageCount;</div><div class="line">if (toIndex &gt; array.size()) &#123;</div><div class="line">    toIndex = array.size();</div><div class="line">&#125;</div><div class="line"></div><div class="line">return array.subList(fromIndex, toIndex);</div></pre></td></tr></table></figure></p>
<p>注意到这里使用了门面模式，通过DruidStatManagerFacade去操作druid的核心类DruidDataSource。<br>接下来我们来看看druid是如何记录sql执行以及如何存储这些记录的。看一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public List&lt;Map&lt;String, Object&gt;&gt; getSqlStatDataList(Integer dataSourceId) &#123;</div><div class="line">        //获取数据源实例</div><div class="line">        Set&lt;Object&gt; dataSources = getDruidDataSourceInstances();</div><div class="line">        //若数据源id为空，则获取所有数据源数据</div><div class="line">        if (dataSourceId == null) &#123;</div><div class="line">            List&lt;Map&lt;String, Object&gt;&gt; sqlList = new ArrayList&lt;Map&lt;String, Object&gt;&gt;();</div><div class="line"></div><div class="line">            for (Object datasource : dataSources) &#123;</div><div class="line">                sqlList.addAll(getSqlStatDataList(datasource));</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            return sqlList;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        for (Object datasource : dataSources) &#123;</div><div class="line">            if (dataSourceId != null &amp;&amp; dataSourceId.intValue() != System.identityHashCode(datasource)) &#123;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            return getSqlStatDataList(datasource);</div><div class="line">        &#125;</div><div class="line">        // 小编觉得此处的return好像是多余的，但是增加了程序的健壮性</div><div class="line">        return new ArrayList&lt;Map&lt;String, Object&gt;&gt;();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>看到这里我们一定很好奇druid是如何维护这个dataSource的呢？<br>接下来会比较枯燥的代码，列位看官可以以个舒服的姿势看下去，最好是能有杯茶，放点枸杞是极好的。<br>我们直接进入DruidDataSource，嗯，这是一个很大很大的类，果然国内人写代码就是跟国外的不一样。<br>继续我们上面的跟踪。DruidDataSource里维护一个JdbcDataSourceStat的对象dataSourceStat来记录jdbc数据源相关信息。然后在JdbcDataSourceStat里通过LinkedHashMap<string, jdbcsqlstat="">来记录sql的执行记录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//初始化大小为16，负载因子为0.75，以插入顺序为排列顺序</div><div class="line">sqlStatMap = new LinkedHashMap&lt;String, JdbcSqlStat&gt;(16, 0.75f, false)</div></pre></td></tr></table></figure></string,></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public DruidDataSource(boolean fairLock)&#123;</div><div class="line">        super(fairLock);</div><div class="line">        //根据系统配置初始化监控内存</div><div class="line">        configFromPropety(System.getProperties());</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>现在我们知道了所有的监控记录都是放在内存里的，接下来我们来看看druid是如何监控到sql执行并放到内存里的。</p>
<h2 id="WebStatFilter"><a href="#WebStatFilter" class="headerlink" title="WebStatFilter"></a>WebStatFilter</h2><p>可能大家已经猜到了，既然数据库的状态的变化是由外部请求引起的，那么监听记录的保存肯定是对请求的追踪，接下来我们就看看WebStatFilter是如何跟踪请求执行的。<br>直接看WebStatFilter的doFilter的方法，druid对请求以及请求的session,webApp的状态，请求url进行了记录，我们没看到sql的相关实体类，进一步看WebRequestStat里有相关jdbc属性记录：<br><img src="/images/druid/druid_webRequestStat.png" alt="webRequestStat"><br>既然有这些属性必然会在执行sql的时候进行相关属性的变更，请求的执行必然会涉及连接池去连接，那么会不会在连接的通过切面之类的完成呢，考虑druid要做兼容，最有可能通过过滤器来做，有了这个思路我们在源码目录里找到了过滤器的目录，看到StatFilter，看类名我们就知道了就是对请求各种监控的更新的过滤器。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>好了，对于druid的监听就介绍到这里了，里面还有很多细节，在这里就不介绍了，因为。。。。我也没完全弄懂！！！！！，下一个我们将介绍druid的核心连接池实现。</p>
]]></content>
      
        <categories>
            
            <category> java中间件 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> druid </tag>
            
            <tag> spring-boot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring-boot里druid连接池配置（一）]]></title>
      <url>/spring-boot%E9%87%8Cdruid%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>J2EE项目大部分都会涉及到数据库，为了提高操作数据库的性能，提高访问的并发量，大部分的应用会选择使用数据库连接池，目前比较成熟的数据库连接池有许多，像c3p0,dhcp等已经成为ORM中间件的标配。druid作为数据库连接池的后起之秀，号称史上性能最好的数据库连接池，逐步的被广泛应用于互联网公司项目中。今天介绍一下druid在spring-boot里的简单的使用。后续将更新druid的一些配置含义</p>
<h2 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h2><p>小编使用了druid目前支持的集成spring-boot版本，主要的maven依赖如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.1.3&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.1.1&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.2.14&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;3.1.0&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h2><p>数据库使用mysql数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">####################数据库配置-start#############################</div><div class="line">spring.datasource.druid.url=jdbc:mysql://xxxx:3306/dataBaseName?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true</div><div class="line">spring.datasource.druid.username=root</div><div class="line">#spring.datasource.druid.password=123456</div><div class="line"># 生成的加密后的密码</div><div class="line">spring.datasource.druid.password=HT+5KPmyjBjCFi3+DbO0L8epACBi+m9i6l3R1D6pllgLPPLal7m8p1blvPUijlnx8A9pYZEDmA4Bbr5K1/gNJQ==</div><div class="line"># 启用ConfigFilter</div><div class="line">spring.datasource.druid.filter.config.enabled=true</div><div class="line">spring.datasource.druid.driver-class-name=com.mysql.jdbc.Driver</div><div class="line">####################数据库连接池配置-start#######################</div><div class="line">spring.datasource.druid.initial-size=1</div><div class="line">spring.datasource.druid.max-active=20</div><div class="line">spring.datasource.druid.min-idle=1</div><div class="line">spring.datasource.druid.max-wait=50000</div><div class="line">spring.datasource.druid.pool-prepared-statements=true</div><div class="line">spring.datasource.druid.max-pool-prepared-statement-per-connection-size=20</div><div class="line">spring.datasource.druid.validation-query=select 1 from user_info</div><div class="line">spring.datasource.druid.validation-query-timeout=30000</div><div class="line">spring.datasource.druid.test-on-borrow=false</div><div class="line">spring.datasource.druid.test-on-return=false</div><div class="line">spring.datasource.druid.test-while-idle=true</div><div class="line">spring.datasource.druid.time-between-eviction-runs-millis=60000</div><div class="line">spring.datasource.druid.filters=stat,wall,log4j</div><div class="line">####################数据库连接池配置-end#########################</div></pre></td></tr></table></figure></p>
<h2 id="spring-boot初始化配置"><a href="#spring-boot初始化配置" class="headerlink" title="spring-boot初始化配置"></a>spring-boot初始化配置</h2><p>使用druid的第一个好处是它帮我们实现了简单的数据库监控，我们能监控sql执行的情况。通过配置druid自定义的filter和servlet，我们能通过浏览器查看数据库相关状态和应用sql执行情况，同时还能帮我们统计应用请求情况哦。<br>这里我们使用java代码的方式配置druid的filter和servlet，使用注解的配置莫名其妙的未生效让人很捉急。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @author xk</div><div class="line"> * @createTime 2017/9/18 0009 上午 10:47</div><div class="line"> * @description</div><div class="line"> */</div><div class="line">@Configuration</div><div class="line">public class DruidConfiguration &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 配置StatView的Servlet</div><div class="line">     */</div><div class="line">    @Bean</div><div class="line">    public ServletRegistrationBean DruidStatViewServlet()&#123;</div><div class="line">        ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(new StatViewServlet(),&quot;/druid/*&quot;);</div><div class="line">        //添加初始化参数：initParams</div><div class="line">        //白名单：</div><div class="line">        servletRegistrationBean.addInitParameter(&quot;allow&quot;, &quot;127.0.0.1&quot;);</div><div class="line">        //IP黑名单 (存在共同时，deny优先于allow) : 如果满足deny的话提示:Sorry, you are not permitted to view this page.</div><div class="line">        servletRegistrationBean.addInitParameter(&quot;deny&quot;, &quot;192.x.x.x&quot;);</div><div class="line">        //登录查看信息的账号密码.</div><div class="line">        servletRegistrationBean.addInitParameter(&quot;loginUsername&quot;, &quot;admin&quot;);</div><div class="line">        servletRegistrationBean.addInitParameter(&quot;loginPassword&quot;, &quot;123456&quot;);</div><div class="line">        //是否能够重置数据.</div><div class="line">        servletRegistrationBean.addInitParameter(&quot;resetEnable&quot;, &quot;false&quot;);</div><div class="line">        return servletRegistrationBean;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 配置statView的Filter</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    @Bean</div><div class="line">    public FilterRegistrationBean druidStatFilter()&#123;</div><div class="line">        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(new WebStatFilter());</div><div class="line"></div><div class="line">        //添加过滤规则.</div><div class="line">        filterRegistrationBean.addUrlPatterns(&quot;/*&quot;);</div><div class="line"></div><div class="line">        //添加不需要忽略的格式信息.</div><div class="line">        filterRegistrationBean.addInitParameter(&quot;exclusions&quot;, &quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&quot;);</div><div class="line">        //添加数据库sql监控</div><div class="line">        filterRegistrationBean.addInitParameter(&quot;profileEnable&quot;,&quot;true&quot;);</div><div class="line">        return filterRegistrationBean;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然大家别忘了数据源的配置和mybatis的配置，这里我不做介绍。</p>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>应用跑起来，浏览器输入localhost:port/druid/,就会进入登录页，输入账号密码，即可进入首页，如下图：<br><img src="/images/druid/druid_index_view.png" alt="druid监控页图"></p>
<h2 id="数据库安全配置"><a href="#数据库安全配置" class="headerlink" title="数据库安全配置"></a>数据库安全配置</h2><p>使用druid的第二个好处就是实现了密文的数据库账号密码配置的加密,废话不多说，我们来看看怎么对我们的密码进行加密。<br>cmd到druid的jar包目录下，执行：java -cp druid-1.1.3.jar com.alibaba.druid.filter.config.ConfigTools you_password<br><img src="/images/druid/druid_password.png" alt="druid密码加密"><br>这里取public-key作为解密公钥，password即为加密后的密码。<br>配置文件里修改配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">spring.datasource.druid.password=HT+5KPmyjBjCFi3+DbO0L8epACBi+m9i6l3R1D6pllgLPPLal7m8p1blvPUijlnx8A9pYZEDmA4Bbr5K1/gNJQ==</div></pre></td></tr></table></figure></p>
<p>添加公钥配置和启用使用加密方法的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//生成的公钥</div><div class="line">public-key=MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAMIQ1SdCmGJlswLkNvh5rpySGPxZXr9bfFei5J4h7/q9XVlqePLcOTVkyQ0je4Gnnp2ZQPlCBsAo5ZPEXJShgRUCAwEAAQ==</div><div class="line">//配置 connection-properties，启用加密，配置公钥。</div><div class="line">spring.datasource.druid.connection-properties=config.decrypt=true;config.decrypt.key=$&#123;public-key&#125;</div></pre></td></tr></table></figure></p>
<p>启用configfilter，使加密生效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">spring.datasource.druid.filter.config.enabled=true</div></pre></td></tr></table></figure></p>
<p>详细代码：<a href="https://github.com/xkupc/druid-spring-boot" target="_blank" rel="external">https://github.com/xkupc/druid-spring-boot</a><br>参考内容：<a href="https://github.com/alibaba/druid" target="_blank" rel="external">https://github.com/alibaba/druid</a>  <a href="https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter" target="_blank" rel="external">https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter</a></p>
]]></content>
      
        <categories>
            
            <category> java中间件 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> druid </tag>
            
            <tag> spring-boot </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
